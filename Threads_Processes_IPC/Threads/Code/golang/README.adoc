:toc:
:toclevels: 6

== go routine(Threads)
* A goroutine is a lightweight thread of execution managed by the Go runtime. 
* Goroutines are inexpensive to create and manage, and they can be used to improve the performance of concurrent programs.
```go
package main

import (
    "fmt"
    "time"
)

func sayHello() {
    fmt.Println("Hello from goroutine!")
}

func main() {
    // Start a goroutine
    go sayHello()

    // Print from the main goroutine
    fmt.Println("Hello from main!")

    // Sleep for a while to allow the goroutine to execute
    time.Sleep(time.Second)
}

$ go run main.go
Hello from main!
Hello from goroutine!
```

== 10 Threads
```go
package main
import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    // defer: keyword in Go schedules a function call to be executed just before the surrounding function returns.
    // ie wg.Done() would be called when surrounding function finishes
    defer wg.Done()
    fmt.Printf("Worker %d started\n", id)
    time.Sleep(time.Second) // Simulate work
    fmt.Printf("Worker %d finished\n", id)
}

func main() {
    // Create WaitGroup object
    var wg sync.WaitGroup

    // Number of goroutines to create
    numWorkers := 10

    // Add numWorkers to the WaitGroup
    wg.Add(numWorkers)

    // Create goroutines
    for i := 1; i <= numWorkers; i++ {
        go worker(i, &wg)
    }

    // Wait for all goroutines to finish
    wg.Wait()

    fmt.Println("All workers finished")
}

$ go run test.go
Worker 10 started
Worker 8 started
Worker 9 started
Worker 2 started
Worker 1 started
Worker 6 started
Worker 3 started
Worker 4 started
Worker 5 started
Worker 7 started
Worker 10 finished
Worker 8 finished
Worker 1 finished
Worker 9 finished
Worker 2 finished
Worker 3 finished
Worker 6 finished
Worker 4 finished
Worker 7 finished
Worker 5 finished
All workers finished
```

== waitgroup
* sync.WaitGroup is a synchronization primitive provided by the Go standard library in sync package
* it is used to synchronize the execution of a group of goroutines.

=== How it works
* A WaitGroup maintains shared counter internally(which is initially set to 0). counter is thread-safe.
* At start of goroutine wg.Add(numberOfWorkers) is called. This makes counter=10
* goroutine finishes (defer make wg.Done() to called after function finishes), and counter is decremented
* wg.Wait() method in main waits until counter=0

=== defer
* defer: keyword in Go schedules a function call to be executed just before the surrounding function returns.
* ie wg.Done() would be called when surrounding function finishes
* defer wg.Done() is called reliably, even in case of errors or unexpected goroutine termination.
