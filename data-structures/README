Big O(n)
Complexity:
1. worst-case: maximum number of steps taken in any instance of size n
2. best-case: minimum number of steps taken in any instance of size n.
3. average-case: average number of steps over all instances of size n

After all, we don’t really
care whether one sorting algorithm sorts six items faster than another, but seek
which algorithm proves faster when sorting 10,000 or 1,000,000 items.

Big Oh notation
1. ignores the difference between multiplicative constants.
	f(n) = 2n and g(n) = n are identical

For all n ≥ n0. We are not concerned about small values of n (i.e. , anything to the left of n0 )
a. f(n) = O(g(n)). c.g(n) is upper bound of f(n). Always f(n)≤ c·g(n)
b. f(n) = Ω(g(n)). c.g(n) is lower bound of f(n). Always f(n)≥ c·g(n)   [Ω:Omega]
c. f(n) = Θ(g(n)). c1·g(n) ≥ f(n) ≥ c2·g(n) [Θ:Theta]


CLASSIFICATION OF DATA STRUCTURES:
		Contigious					Linked
Based on	Arrays						Pointers
	  	contigously allocated memory area		distinct chunks of memory bound together by pointers
Examples	arrays,matrices,heaps & hash tables		lists, trees, and graph adjacency lists
Advantages	1. Constant time access from index,		1. Insertion,deletion is simpler wrt arrays. Insert/delete in
		bcoz index maps to memory address		arrays will require shifting.
		2. No space wasted for storing links		2. When record is larger moving pointers is easier wrt moving
		to next elements				record itself.
		3. Excellent memory/Cache locality:
		- Physical continuity b/w successive data
		elements helps exploit high-speed cache mem.
Disadvantage	1. Size cannot be adjusted in mid of program	1. Space requirement is high. Pointer to next node takes 
		execution.					significant space.
		Solution: Dynamic Arrays			2. Random access not allowed.
								3. Cache locality not good, since jumps are done using ptrs.
		
DYNAMIC ARRAYS?
	array-size
t=t0	1
t=t1	1 exhausted, Double the allocation, Allocated:2
	- Every time space is exhausted, its doubled.
	- Allocate new contiguous array of size 2m, copy contents of old array to the lower half of the new one, return
How many times reallocation should be done?
1->2->4->8->16	For n elements logn
No of times movement happens for elements? Each of the n elements move only two times on average,

		
		
DATA STRUCTURES
1. Dictionary:data type permits access to data items by content.
	a. Search(D,k) – Given a search key k, return a pointer to the element in dictionary D 
	whose key value is k, if one exists.
	b. Insert(D,x) – Given a data item x, add it to the set in the dictionary D.
	c. Delete(D,x) – Given a pointer to a given data item x in the dictionary D, remove it from D.
	d. max(D),min(D) - return max element or min
	
