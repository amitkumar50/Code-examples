:toc:
:toclevels: 6

=== Array
* *resize of array:* Not possible since, size is part of declaration
```go
func main() {
  arr := [6]int{1,2,3,4,5,6}    //[n values] type {}
  var len = len(arr);
}
```

=== Slice = C++(vector`<int>`) = link:Languages/Programming_Languages/Rust/Collections[Rust(vec`<i32>`)]
* This is just a Reference to underlying array
* A slice represents a view of contiguous sequence of elements in memory.
* Slices are used to borrow a portion of an array or a whole array, allowing to work with subsets of data without needing to copy or own the data
* *Denoted by `[]`*
* *Slice contains 3 components*
** _1. Pointer to underlying array:_ A slice holds a reference to the underlying array that stores the elements.
** _2. Length:_ number of elements in slice.
** _3. Capacity:_ maximum number of elements it can hold 
```go
package main

func main() {
// SLICE DECLARATION
  var arr []int                       //var is used to declare a variable. T=int type of the elements that the slice can hold
  slice := make([]int, 5)             //make([]T, length). Creates a slice with length 5 and capacity 5

// INITIALIZATION
  arr := []int {1,2,3,4,5,6}        //Length of the slice is determined by the number of elements provided
  arr_slice := arr[1:4]             //Creates a new slice from index 1 to 3 (exclusive) from existant array
  
// SLICE MODIFICATION: Changing elements of a slice modifies the corresponding elements of its underlying array 
  slc[0] = 899
  fmt.Println(arr[1])             //899

// length: no of elements slice contains
// capacity: no of elements in underlying array
  fmt.Println(len(slc),cap(slc))  //3 5

// NIL SLICE
  var nilSlc[]int
  fmt.Println(len(nilSlc), cap(nilSlc))   //0 0

//RESLICING:  Slice the Slice's length to new length
    slc1 := []int{10,20,30,40,50}
    slc1 = slc1[:0]
    fmt.Println(slc1)                       //[]
    slc1 = slc1[:4]
    fmt.Println(slc1)                       //[10,20,30,40]
    slc1 = slc1[2:]
    fmt.Println(slc1)                       //[30,40]

//MAKE SLICE: make() allocates a zeroed array and returns a slice that refers to that array
    slc2 :=make([]int, 5)                   //[0 0 0 0 0]
    fmt.Println(slc2)

//APPEND TO SLICE: append(slice, element). Append new element to slice
    slc3 := []int{10,20,30,40,50}           //[10 20 30 40 50 60]
    slc3 = append(slc3,60)
    fmt.Println(slc3)
}
```

=== Vector
==== 2D Vector = `[][]` = slice of slices
```go
package main
func main() { 
  // Method-1: Declare a 2D vector
  var test [][]int     
  
  // Method-2: Declare an empty 2D vector
  test := make([][]int, rows)
  // Initialize each row with specific length
  for i := range vector {
    test[i] = make([]int, cols)
  }
  
  // Method-3: Declare an empty 2D vector
  var test [][]int
  // Initialize each row with specific length
  for i := 0; i < rows; i++ {
    test = append(test, make([]int, cols))
  }


  // Initialize the 2D vector with values
  test = [][]int {
    1,2,3
    4,5,6
  }
  
  // Accessing elements in the 2D vector
  fmt.Println(vector[0][0]) // Output: 1
}
```

=== link://https://tour.golang.org/basics/7[Functions]
```go
package main

import(              //import: Include Package/Header-File. Grouping imports
    "fmt"            // fmt includes functionality for formatting output to screen
    "time"
)

/* PARAMETERS:
 - type comes after the variable name
 - When 2 or more consecutive function parameters share a type, we can omit type from all but the last.*/
//func add(x int, y int) int{	//valid
func add(x, y int) int {	//valid
	return x + y
}
```

==== Multiple Returns, Naked Return
```
//The swap function returns two strings.
func swap(x, y string) (string, string) {
	return y, x
}


//NAKED RETURNS: 
//return statement without arguments
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

/*
println: Prints in newline
printf: Just prints no new line
*/
func main() {
	fmt.Println(add(42, 13))
	fmt.Printf("  hello  ")
	fmt.Println(time.Now())
	a, b := swap("hello", "world")
	fmt.Println(a, b)
	fmt.Println(split(17))
}

/*
# /usr/local/go/bin/go build add.go
# ./add
55
  hello  2020-04-01 08:53:55.869681784 +0530 IST m=+0.000048093
world hello
7 10
*/
```

==== Function values
Functions are values too. They can be passed around just like other values.
```
test := func(x, y float64) float64 {
             return (x + y)
}
fmt.Println(test(5, 12))		//17
```

==== Closure Function = Lambda C++
A function that references variables from outside its body.
```
func add() func(int) int {
        sum := 10
        return func(x int) int {
                sum += x
                return sum
        }
}
func main() {
        a := add()
        fmt.Println(a(9))
}
```

=== Loops
==== for
```
 for initialization; condition; increment/decrement {
    // Code to be executed
 }

for i := 1; i < 10; i++ {}
```

==== while
```
for i < len(arr) {
 ...
 i++;
}
```

==== range
This is for loop iterating over slice or map.
 1. Returns: when iterating over slice
  value-1: index inside slice
  value-2: copy of the element at that index.
 2. index or value anything can be skipped using "_"
```
package main
import "fmt"
var slc = []int{1, 2, 3}        //Created Slice
func main() {
        for i, v := range slc {
                fmt.Printf("slc[%d]=%d,\t", i, v)       //slc[0]=1, slc[1]=2, slc[2]=3  //1
        }
        for _, v := range slc {
                fmt.Printf("slc[]=%d,\t", v)       //slc[]=1, slc[]=2, slc[]=3  //2
        }
}
# /usr/local/go/bin/go build range.go 
# ./range 
slc[0]=1,	slc[1]=2,	slc[2]=3
slc[]=1,	slc[]=2,	slc[]=3
```

=== Package/Modules in Go = link:/Languages/Programming_Languages/c%2B%2B/namespaces[C++(namespace)] = link:/Languages/Programming_Languages/Rust/Crates_Packages_Modules[Rust(crates)]
- The package statement is always the first line in a Go file. It specifies the package name that the file belongs to.
- This is unique namespace for (variables, functions, types, etc.) defined within the package.

==== main package
- main package is a special package in Go. It is the entry point for an executable program.
- When we create a Go program, it must have a main package, and within that package, there must be a main function.

==== import statement
import keyword is used to include external packages/modules in Go program.
```go
import "fmt"
or 
import (              //import multiple packages
    "fmt"
    "math"
)

// Use functions in package using dot statement
fmt.Println("Hello, world!")
```

=== Pointers
 a. & operator generates pointer to operand
 b. * operator derefences pointer's value
 c. Unlike C there is no pointer arithematic in go
```
package main
import "fmt"
func main() {
        a := 1
        ptr := &a                       //Points to a
        fmt.Println(*ptr)               //1
        //ptr = ptr + 1;                //c
}
# /usr/local/go/bin/go build pointer.go
# ./pointer
1
```

=== Statements
==== defer statement
defer statement defers execution of a function until the surrounding function returns.
```
package main
import "fmt"
func main() {
        defer fmt.Println("world")
        fmt.Println("hello")
}
# /usr/local/go/bin/go build defer-statement.go
# ./defer-statement
hello
world
```
==== if statement
a. Expression not surrounded by parentheses ( ) but the braces { } are required.
b. if statement can start with Short statement to execute before condition.
c. Variables declared in if statement are also avaiable in else block.
```
package main
import (
        "fmt"
        "math"
)
func main() {
        a := 1.1 
        if a < 4 {                              //1a
                fmt.Println("Hi")
        }

        b := 2.2
        if v := math.Pow(a, b); v < 4 {         //1b
                fmt.Println("There")
        } else {                                //1c
                fmt.Println(v)
        }
}
# /usr/local/go/bin/go build if-statement.go
# ./if-statement
Hi
There
```

==== Switch
 a. breaks statement is provided automatically in go
 b. Unlike C,C++ swtich only runs the selected case, not all cases that follow
 c. Switch cases, Need Not to be constants. values involved need not to be integers.
```
package main
import (
        "fmt"
        "runtime"
)
func main() {
        switch os := runtime.GOOS; os {
        case "darwin":
                fmt.Println("OS X")             //a. go provides break automatically
        case "linux":                           //c. switch case need not to be constants
                fmt.Println("Linux")
        case "ubuntu":
                fmt.Println("Ubuntu")
        default:
                fmt.Printf("%s.\n", os)
        }
}
# /usr/local/go/bin/go build switch.go
# ./switch
Linux
```

=== Variables
==== Declaration & Initialization
```go
fun main() {
     // Variable declaration and initialization
    var num int = 10
    var name string = "John Doe"
    var flag bool = true
 
    // Variable declaration without initialization (zero value assignment)
    var age int
    var score float64
    var isValid bool
 
     // Short variable declaration (with type inference)
    count := 5
    message := "Hello, world!"
    isFound := false
 
    // Printing the variables
    fmt.Println(num)
    fmt.Println(name)
}
```

==== Built in variables
- bool, string, int  int8  int16  int32  int64, uint uint8 uint16 uint32 uint64 uintptr,
- byte{alias for uint8}, rune{alias for int32}//Represents a Unicode code point, float32 float64,
- complex64 complex128
