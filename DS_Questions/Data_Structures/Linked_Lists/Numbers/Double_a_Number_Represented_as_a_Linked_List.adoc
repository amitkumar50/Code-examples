:toc:
:toclevels: 6

== link:https://leetcode.com/problems/double-a-number-represented-as-a-linked-list[2816. Double a Number Represented as a Linked List]
You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.

Return the head of the linked list after doubling it.

Example 1:

image::https://assets.leetcode.com/uploads/2023/05/28/example.png?raw=true[ex-1]

```c
Input: head = [1,8,9]
Output: [3,7,8]
Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.
```

== Approach-1. Store doubled number in vector and new LL. Time:O(n), Space:O(n)
=== Logic
* Store number into vector from Linked List
```c
1 -> 8 -> 9

v |1|8|9|
```
* Multiply each number by 2 and store in same vector, if a carry is left, insert at beginning
```c
v |3|7|8|
```
* Convert the vector to LL
```c
  3 -> 7 -> 8
```

=== Complexity
* Time: O(n)
* Space: O(n). Extra vector is created. New LL is created and returned

=== Code
==== CPP
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* doubleIt(ListNode* head) {
        read_into_vector(head);
        double_the_number();
        return create_ll_from_vector();
    }
private:
    vector<int> v;
    void read_into_vector(ListNode* head) {
        while (head) {
            v.push_back(head->val);
            head = head->next;
        }
    }
    void double_the_number() {
        // Keep track of carry on every multiply operation
        int i = v.size() - 1, carry = 0;
        while (i >= 0) {
            int pro = v[i] * 2 + carry;
            v[i] = pro % 10;  // Update the value directly with the doubled value
            carry = pro / 10;
            --i;
        }
        if (carry)
            v.insert(v.begin(), carry);
    }
    ListNode* create_ll_from_vector() {
        return create(0);
    }
    ListNode* create(int i) {
        if (i > v.size()-1)
            return nullptr;
        ListNode* p = new ListNode(v[i]);
        p->next = create(i+1);
        return p;
    }
};
```

== Approach-2. Modify LL in place. Time:O(n), Space:O(1)
=== Logic
* Reverse the Linked list
```c
1 -> 8 -> 9

9 -> 8 -> 1
```
=== Code
==== CPP
```cpp
```
