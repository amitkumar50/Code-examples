# Virtual & Physical Memory
**Only Read Modern-Operating-System-Tanenbaum.pdf because internet is Garbage**

# What is VM?
- This is hard disk.
- **Concept** 
  - VM is bits and pieces of many programs in RAM/Physical memory at one time.
  - Each program has its own address space or virtual address space which is divided into fixed-size units called **PAGES** and Process of dividing Hard-Disk to equal-sized blocks is called **PAGING**. Pages are contiguous range of addresses.
  - Units inside Physical Address space(RAM) are called **Page FRAMES**. Pages and frames are of *SAME SIZE*.
  - Pages are mapped to physical Memory(RAM), but not all pages have to be in physical memory to run the program. This mapping is generated by MMU.
  - Tranlation from Virtual to Physical Address is done by **MMU(Memory Management Unit)**.
  - **Memory Manager** It manages memory(keep track which parts of memory are in use, allocate memory to processes when they need it, and deallocate it when they are done)

# Why VM is required?
- Now-a-days Complex programs require minimum `1 GB RAM`.
- Bigger programs need more RAM(>1 GB) and there are 10s of these on high end programs(Eg: in aircraft deisgning).
- So if 10 progmras are there each requiring `1 GB`, then system need to make `10 GB` available instantaneouly?

# VM Example
- Consider a system having 
  - Physical/Memory or RAM = 32KB
  - Virtual Memory or Hard Disk = 64KB
    - To access 64KB = 64`*`1024Bytes = 65536'th bit computer genereates 16 bit addresses. 65536 = 2<sup>16</sup>. These are VIRTUAL ADDRESSES.
  - Page Size = 4KB = 4`*`1024 = 4096 Bytes. In Real systems Page sizes might be as large as 64KB.
    - **How many PAGES**
      - Virtual Pages = 64KB/4KB = 16         //Means 16 pages on Hard Disk
      - Physical Pages = 32KB/4KB = 8         //8 frames on RAM
    - Every page begins on a multiple of 4096 and ends 4095, so 4K-8K really means 4096-8191 and 8K to 12K means 8192-12287.      
![ImgURL](https://i.ibb.co/GCFwbL0/virtual-physical.png)

### Accessing the pages/CONVERSION OF VIRTUAL to PHYSICAL Addresses
> Never try accessing Virtual address directly. Its not real address and will result in corruption.
#### 1. `MOV REG 0`
- Program tries to access address 0. 0 is the virtual address. Virtual address is sent to MMU for translation.
- 0 falls on 1st page (0-4095) which according to its mapping is page frame 2(8192-12287). MMU sends 8192 onto Bus
- Please note, Bus does not know anything about addresses, whichever address is placed on it carries.
- Thus, MMU has mapped all virtual addresses between 0 and 4095 onto physical addresses 8192 to 12287.
#### 2. `MOV REG 8192` = `MOV REG 8k`
- Page(8192) maps to page-frame-6(24k = 24`*`1024 = 24576)
- `MOV REG 8192` becomes `MOV REG 24576`
#### 3. Acesss virtual address `20500`
- On Virtual-table 20500 falls on 5th page(20k = 20`*`1024 = 20480). 
- But 20500 is not start of page but it falls 20 inside. 20500 = 20480 + 20.
- To access Physical address, offset is added = (12k + 20) = 12`*`1024 +20 = 12288 + 20 = 12308. 
- Address 12308 is placed on Bus.
#### 4. `MOV REG 32780` = `MOV REG 32k+12` 
- **Request to reference a unmapped address**.
- Now, MMU finds page in unmmaped, CPU **TRAPS the OS**. This is called **PAGE FAULT**.
  - **Page Fault**? OS picks a least-used page frame and writes its contents back to the disk, then copies page into page frame changes mapping, and restarts the trapped instruction. This is called **Page Eviction**. Movement of pages in/out of RAM is done by **SWAPPER**.
    - Example Let OS decides to evict Page number=0. 
      - Page=0 is mapped to frame=2, ie at physical address 8192.
      - Virtual Page 8 = 32k is loaded into physical memory 8192.
      - Changes done in MMU.  a. Make entry of virtual-page=0(as unmapped)  b. Place 1 at frame=2 at Virtual-Page-8's entry.

# Fragment/Page No(4 bits) + Offset(12 bits) 
- For 64k Virtual Memory. MMU uses 16 bit scheme.
- Virtual Page(4 bit) 
  - 2<sup>4</sup> = 16. With 4 bits we can access 16 pages.
  - Page no is used as index into Page Table, outputting the Physical Page no.
  - This is always high order bits.
  - However 3 or 5 bits can also be taken for the page. Different splits imply different page sizes.
- OFFSET(12 bit)
  - 2<sup>12</sup> = 4096. With 12 bits we can access all 4096 bits inside a page.
  - These are always low order bits.
![ImgURL](https://i.ibb.co/86bzCf4/MMU-opearation.png)   

### VPN(Virtual Page Number)
- This is content of virtual-table.
- This is used as an index into the page table to find the mapping for that virtual page.
- And then from Page-Table, Page-Frame is found.
- VPN + offset creates 
| **Present/Absent bit ->** | 1 | 1 | 1 | 0 | ... |
| --- | --- | --- | --- | --- | --- |
| **VPN ->** | 0010 = 2 | 0001 = 1 | 0110 = 6 | 0000 |  |
| **Index ->** | 0 | 1 | 2 | ... | 15 |

### Accessing the pages/CONVERSION OF VIRTUAL to PHYSICAL Addresses
#### Mov REG 8196
- Access addres=8196. This is virtual address. Binary=0010000000000100. Page No=0010, Offset=000000000100
- page_table`[page_no]` = page_table`[0010]` = page_table`[2]` = 110 = 6
  - Access 6th page frame
- Physical-Address = `0110``000000000100` = `output_of_page_table_entry=VPN``offset_copied_as_it_is` = 0110000000000100
- If the Present/absent bit is 0, a trap to the OS is caused.
