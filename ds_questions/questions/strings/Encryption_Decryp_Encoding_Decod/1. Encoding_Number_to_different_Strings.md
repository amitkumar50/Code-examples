### [Decode Ways](https://leetcode.com/problems/decode-ways/)
### [Solution](https://www.geeksforgeeks.org/count-possible-decodings-given-digit-sequence/)
- String contains letters from `A` to `Z`. determine the total number of ways to decode it.
```c
'A' -> 1, 'B' -> 2, ..., 'Z' -> 26
0 is not valid character

Input: "21026"
Output: 2         //2 ways possible
How?
2,1,0,2,6 -> Not valid. Since 0 is invalid
21,0,2,6  -> Not valid. Since 0 is invalid
2,10,2,6  -> Valid   BJBF
210,26    -> Not valid. 3 characters cannot be combined
2,10,26   -> Valid   BJZ

Input: "226"
Output: 3       //3 ways possible
2,2,6  -> Valid  BBF
22,6   -> Valid  VF
2,26   -> Valid  BZ
226    -> Invalid

Input: "024"
Output: 0     //1st character should be valid
```

### Logic (Dynamic Programming)
> Consider example `s = 21026`  
- (Step-1) Take dp table of size+1. ie if input string size=5, take tab of size=6.
  - Dp Table shows number of possible ways to decode the string to present index.
    - Value at `dpTable[2]` shows number of ways possible with `s[0],s[1]`
    - Value at `dpTable[3]` shows number of ways possible with `s[0],s[1],s[2]`
```c++
    s   = 2 1 0 2 6     //size=5
dpTable = 0 0 0 0 0 0   //size=6
```
- (Step-2) `dpTable[0] = dpTable[1] = 1`. Means if string has 2 characters, **Minimum** 1 possible way is there
```c++
  s = 10.
  Ways: 10
  
  s = 23
  Ways: [2,3] [23]  //Min 1 possible way is there
  
Start from `s[2]`. if `s[1] > '0'`  
```
- (Step-3) Start from `s[2]`.
- (Step-4) Check word formed using `s[i-1]s[i]`. `if (s[i-1] > 0)`, means whatever present element maybe. This is a valid no.
```c++
Possible ways: 1
  s = "210"   
2,1,0 -> Invalid
2,10  -> Valid
21,0  -> Invalid

  if (s[i-1] > '0')
    dp[i] = dp[i-1]
```
- (Step-5) 
    - We will check only `2` elements at a time, in reverse order.
      - ie At index=3, we will check s[1],s[2].
        - if `s[1] == 1`  //means 1 way exists
        - if `s[2]==2 && s[3]<7`  //This is valid number and way is considered
  - (Step-2) Make 0th,1st element of tab=1
    - `tab[0]=tab[1]=1`
    - **Meaning** Atleast 1 way is there. 
      - Example: `99`. 1 way is always there.
      
| input string | 2 | 2 | 6 |
| --- | --- | --- | --- |
| index |        0 | 1 | 2 |
| dp-table     | 1 | 1 | 0 | 0 |

  - (Step-3) Start from i=2
    - i = 2
      - if s[1] > '0', (number of ways = tab[2]) = tab[1])

| input string | 2 | 2 | 6 | |
| --- | --- | --- | --- | --- |
| index |        0 | 1 | 2 |  |
| dp-table     | 1 | 1 | 1 |  |

      - if (s[0] == '1') (number of ways = tab[2]) = tab[2]+tab[1])

| input string | 2 | 2 | 6 | |
| --- | --- | --- | --- | --- |
| index | 0 | 1 | 2 |  |
| dp-table | 1 | 1 | 1 | 2 |

### Code
```c++
class Solution {
public:
    int numDecodings(string s) {
  int size = s.size();

  vector<int> tab(size+1, 0);
  tab[0] = 1, tab[1] = 1;

  //for base condition "0345" should return 0
  if(s[0]=='0')
    return 0;

  for (int i = 2; i <= size; i++)
  {
    tab[i] = 0;

    // If the last digit is not 0, then last digit must add to the number of words
    if (s[i-1] > '0')
      tab[i] = tab[i-1];

    // If second last digit is smaller than 2 and last digit is smaller than 7,
    // then last two s form a valid character
    if (s[i-2] == '1' || (s[i-2] == '2' && s[i-1] < '7') )
      tab[i] += tab[i-2];
  }
  return tab[size];
  }
};
int main()
{
  //string s = "12";    //ok 2
  //string s = "226";   //ok 3
  string s = "1234";    //ok 3
  //string s = "999";   //ok 1
  //string s = "100";   //ok 0
  cout<<tabDecodingDP(s);
  return 0;
}
```
