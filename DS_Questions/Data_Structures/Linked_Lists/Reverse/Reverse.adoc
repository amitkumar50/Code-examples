:toc:
:toclevels: 6

== link:https://leetcode.com/problems/reverse-linked-list/[206. Reverse Linked List]
Given the head of a singly linked list, reverse the list, and return the reversed list.

Example 1:

image::https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg?raw=true[LL Reverse]
```
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```

== Approach-1 (3 pointers)
=== [Self Video Explanation](https://youtu.be/UheqFiqUbgQ)
=== Logic
1. Take 3 pointers pointing 3 consecutive nodes in LL.
```c
  1  ->  2  ->  3  ->  4  ->  N
 /\     /\      /\
 a       b      c
```
2. Make b->next = a. if a is head node, Make its next = NULL
```c
N<-1  <-  2      3  ->  4  ->  N
  /\     /\      /\
  a       b      c
```
3. Move every pointer 1 step a head and so on.
```c
N<-1  <-  2      3  ->  4  ->  N
         /\      /\     /\
          a      b      c
```
=== Complexity
* Time: O(n)
* Space: O(1)

=== Code
```c
#include<iostream>
using namespace std;

struct Node {
  int val;
  Node *next;
  Node(int x) : val(x), next(NULL) {}
};

Node *create(){
  //1->2->3->4->N
  Node *n4 = new Node(4);
  Node *n3 = new Node(3); n3->next = n4;
  Node *n2 = new Node(2); n2->next = n3;
  Node *n1 = new Node(1); n1->next = n2;
  return n1;
}

Node* reverse(Node *head){
  Node *a,*b,*c, *newH;
  if(head)
    a = b = c = head;

  if(a->next != NULL)
    b = c = a->next;

  while(b != NULL){
    c = b->next;
    b->next = a;
    if(a == head){
      a->next = NULL;
    }
    a = b;
    if(c == NULL)
      newH = b;
    b = c;
  }
  printf("Done rev\n");
  return newH;
}

/* Reverse using Recursion
reverse(Node *ptr){
    if(ptr->next != NULL){
        Node *x = reverse (ptr->next);
    }
    x = ptr;
    return ptr->next;
} 
*/

void print(Node* t){
  while(t!=NULL){
    cout << t->val << " ";
    t = t->next;
  }
  cout<<"\n";
}

int main(){
  Node* a = create();
  print(a);
  Node *p = reverse(a);
  print(p);
}
$ ./a.out
1 2 3 4
Done rev
4 3 2 1
```
