**Maximum Score from Performing Multiplication Operations**
- [Approach-1 DP](#a)
  - [Identifying is this DP Problem?](#i)
  - [Logic](#l)
  - Code
    - [CPP](#cpp)
    - [Rust](#rs)

### Maximum Score from Performing Multiplication Operations
- We are given 2 arrays nums(size=n), multipliers(size=m). n>=m
```c
nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
- nums: Number can be choosen from left or right
- multiplier: Number is always choosen from left.
```
- We need to find maximum sum after multiplying numbers from nums, multipliers. **Constriant**:
  - **`nums[i]:`** Choose one number=x from either the start or the end of the array nums.
  - **`multipliers[i]`:** Always choose next number from left in this array.
  - Add `multipliers[i] * x` to your score.
  - Remove x from the array nums.
```c
nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
output=102
                -5x-10  50       [-3,-3,-2,7,1]     [-5,3,4,6]
                  |
                -3x-5   50+15=65    [-3,-2,7,1]        [3,4,6]
                  |
                -3x3    65-9=56        [-2,7,1]        [4,6]
                /   \
             DP/     \Greedy
        1x4=4+56=60   1x6=6+56=62
        [-2,7] [6]   [-2,7] [4]
            |          |
      7x6=42+60=102  7x4=28+62=90
ans=102
```

<a name=a></a>
## Approach-1, DP
<a name=i></a>
### [Identifying is this DP Problem?](/DS_Questions/Algorithms/Dynamic_Programming#i)
- _1. Problem statement: min/max/longest/largest/Nth Number?_ Yes
- _2. Greedy solution does not fit in?_ Yes
- _3. 2. Optimal Substructure Property:_ if optimal(feasible) solution can be constructed from optimal solutions of its subproblems. Yes

<a name=l></a>
### [Logic = DP Template](/DS_Questions/Algorithms/Dynamic_Programming#tem)
- _1. Define State:_ Maximum product at index=i after selecting (left or right) from `nums[i]` and left most from `multiplier[i]`.
- _2. Function to return State:_ Function to calculate max product at every index.
```c
int dp(i, left) {
  return (max product at step i);
}

/////////What is left?///////
left = Number of LEFT operations done in nums
right = Number of RIGHT operations done in nums
i = how many operations we have done so far, which means multipliers[i]

How to find right using left,i?
- Number of elements picked from leftside = left
- Total elements picked = i
- Picked from right = i - left
  - Index of right most element in nums = nums.size() - 1 
  - Index of right most picked element in nums = nums[(nums.size() - 1) - (i - left)]
  
Hence we need 2 state variables i,left only.
```
3. _Recurrence relation to transition between states:_
- At each state we need to decide whether we need to take `nums[left]` or `nums[right]`, then multiply with `multipliers[i]`
- Then add to score
- Remove `nums[left] or nums[right]`, we will not remove rather increment left.
```c
if we
1. Choose left
  gain = multipliers[i]*nums[left]
  next operation = dp(i+1, left+1)
  score = multipliers[i]*nums[left] + dp(i+1, left+1)

2. Choose right
//right=(nums.size() - 1) - (i - left)
  gain = multipliers[i]*nums[right]
  next operation = dp(i+1, left)
  score = multipliers[i]*nums[right] + dp(i+1, left)
  
  //max_product_at_index_i
  dp(i, left) = max(choose_left, choose_right)  
```
4. Base case: Try finding base case from problem itself and logical thinking.
  - Question says min m operations (ie multiplier.size()). Hence when i=0 return 0, since no product generated by that time.
5. Memoize: Store result of operation in array.
  - `dp_arr[i][left]:` Represents the max score possible if i operations have been performed and {left} left operations have been performed.
### Code
<a name=cpp></a>
#### CPP
**[Top Down Approach / Recursive](/DS_Questions/Algorithms/Dynamic_Programming#t)**
```cpp
#include<iostream>
#include<vector>
using namespace std;
using vecI = vector<int>;

class Solution {
    int multiplier_size;
    int nums_size;
    vecI vecNums;
    vecI vecMult;
public:
    int dp (vector<vecI>& dp_arr, int i, int left){
        if (i == multiplier_size)
            return 0;

        if (dp_arr[i][left] == 0) {
                        //Total size      - elements picked from left
            int right = (nums_size - 1) - (i - left);

            int choose_left = vecNums[left]*vecMult[i] + dp(dp_arr,i+1,left+1);
            int choose_right = vecNums[right]*vecMult[i] + dp(dp_arr,i+1,left);
            dp_arr[i][left] = max (choose_left,choose_right);
        }
        return dp_arr[i][left];
    }

    int maximumScore(vecI& nums, vecI& multipliers) {
        multiplier_size = multipliers.size();
        nums_size = nums.size();
        vecNums = nums;
        vecMult = multipliers;
        vector<vecI> dp_arr(multiplier_size, vecI(multiplier_size,0));
        int temp = dp(dp_arr, 0, 0);
        for (int i=0;i<3;++i){
          for (int j=0;j<3;++j){
            cout << dp_arr[i][j] << " ";
          }
          cout << "\n";
        }
        cout << "\n";
        return temp;
    }
};
int main() {   
    vecI nums = {1,2,3};    //14
    vecI multipliers = {3,2,1};
    Solution s;
    cout << s.maximumScore(nums, multipliers);
}
# ./a.out
14 0 0 
5 8 0
1 2 3

14
```
**[Bottom up Approach / Iterative](/DS_Questions/Algorithms/Dynamic_Programming#t)**
- Check Top Down approach 1st
```cpp
    int maximumScore(vecI& nums, vecI& multipliers) {
        vector<vecI> dp_arr(multipliers.size(), vecI(multipliers.size()+1,0));
        
        for (int i = multipliers.size() - 1; i >= 0; i--) {
            for (int left = i; left >= 0; left--) {
                int right = (nums.size() - 1) - (i - left);

                int choose_left = nums[left]*multipliers[i] + dp_arr[i+1][left+1];
                int choose_right = nums[right]*multipliers[i] + dp_arr[i+1][left];

                dp_arr[i][left] = max (choose_left,choose_right);
            }
        }
    }
```
