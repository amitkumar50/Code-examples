:toc:
:toclevels: 6

=== link:https://leetcode.com/problems/counting-bits/description/[338. Counting Bits]
- Given an integer n, return an array ans of length n + 1 such that for each i (0 < = i < = n), ans[i] is the number of 1's in the binary representation of i.
* *Always Do as per REQUIREMENT*
** Solution should be better than O(n log n). Can you do it in *linear time O(n)* and possibly in a single pass?
** Can you do it without using any built-in function (i.e., like __builtin_popcount in C++)?
```c
Example 1:
Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10
```
==== What is meaning of O(n)?
* Without checking bits of number, we should tell on bits of number.
```c
Example: num = 6 = 00000000 00000000 00000000 00000110
Method-1: Left shift 1 and perform Bitwise &, We need 32 shifts for every number.

Requirement: Can we do without looking at bits, ie avoid this 32 time shift?
```

=== Approach-1. Divide by 2. O(nlogn)      //But Requirement is O(n)
==== Logic
```c
          -------
        2/  6        rem=0

          -------  
        2/  3        rem=1

          -------  
        2/  1        rem=1
6 = 110
```
==== Complexity
* *Time: O(nlogn):* With every divide by 2 we are going half and for n numbers

=== Approach-2. O(n*32). Bitwise & with 1 //But Requirement is O(n)
==== Logic
* Take 1, left shift perform & and count.

==== Code
===== CPP
```cpp
class Solution {
public:
    int FindOnes(int a){
        int i = 1, k = 1;
        int ones = 0;
        while (k++ != sizeof(int)*8) {
            if (a & i)
                ones++;
            i = i<<1;
        }
        return ones;
    }
    vector<int> countBits(int n) {
        vector<int> vecOut;
        for (int i=0;i<n+1;++i){
            vecOut.push_back(FindOnes(i));
        }
        return vecOut;
    }
};
```

===== Rust
```rs
use std::mem;
impl Solution {
    pub fn count_bits(a: i32) -> Vec<i32> {
    let mut v = vec![0; (a as usize)+1];
    let mut ones:i32 = 0;
    let mut i:i32 = 1;
    let mut k:i32 = 1;

    for var in 1..a+1 {
        while k as usize != mem::size_of::<i32>()*8 {
            if var & i > 0 {
                ones += 1;
            }
            i = i << 1;
            k += 1;
        }
        v[var as usize] = ones;
        ones = 0;   
        i=1;
        k=1;
    }
    v
    }
}
```

=== link:/Languages/Programming_Languages/C/Bitwise/Count_on_Bits/README.adoc[Approach-3. O(n*(number of ON bits)). Hamming Weight]

=== Approach-4. O(n). Dynamic Programming
==== Logic
* Can we derive number of bits from prev calculated numbers
```c
number    bit    number of ON bits(dp)   Power of 2
0          0           0
1          1           1
2          10          1                y        //power of 2 will always have 1 bit ON
3 =2+1     11          2                         //number of ON bits=(no of ON bits in 2) + (no of ON bits in 1)
4          100         1                y
5 =4+1     101         2    
6 =4+2     110         2                        //4(100) + 2(10) = ON bits on 6=ON Bits in 4 + ON Bits in 2
7 =4+3     111         3
8          1000        1                y
9 =8+1     1001        2
10=8+2     1010        2
```
==== Complexity
* *Time:* O(n). For 0,1 only we need to write bits then we calculate without going into number
* *Space:* O(n). Same sized dp array is needed

==== Code
===== Python
```py
class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)    # Take a dp array of size=n+1 and initialize to 0
        pow_of_2_num = 1      # Used to keep track of number which is power of 2

        for i in range(1, n + 1):            # Iterate from 1 to n
            if pow_of_2_num * 2 == i:        
                # if number is power of 2, it will always have 1 ON bit. 2=10, 4=100, 8=1000
                pow_of_2_num *= 2
                dp[i] = 1
            else:
                dp[i] = dp[i - pow_of_2_num] + 1
            
        return dp
```
