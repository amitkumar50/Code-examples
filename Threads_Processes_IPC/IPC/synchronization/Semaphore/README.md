**[Semaphore](sem)**
- **[Types of Semaphores](#t)**
  - [Binary](#b)
    - [Thread1 signals Thread2 to enter Critical Section, when Thread1 is done](#t1st2)
  - [Counting](#c)
- [Datastructures: sem_t, APIs: sem_init, sem_post, sem_wait](Datastructures_API.md)

<a name=sem></a>
## Semaphore
- A integer whose [atomicity](/Threads_Processes_IPC/Terms) is maintained by kernel.
- **[Interupts](/Operating_Systems/Linux/Kernel/Interrupts) are disalbed breifly for Semaphore Operations**
  - *Why?* Since interrupt can destroy atomic operation and value of semaphore can be unpredictable after processing interrupt(if interrupt is generated by process-2) which want to enter CS.
- **How Semaphore Operation is performed?**
  - _1._ OS first disables [interrupts](/Operating_Systems/Linux/Kernel/Interrupts).
  - _2._ Then reads the value of semaphore. 
    - {Semaphore Down Operation} if(semaphore == 0) puts calling process on a list of blocked processes associated with the semaphore. 
    - {Semaphore Up Operation} If it is doing an up, it must check to see if any processes are blocked on the semaphore. If one or more processes are blocked, one of them is removed from the list of blocked processes and made runnable. 
  - _3._ When all these operations have been completed, interrupts can be enabled again.
```c
  if (variable==1)            //sem_post
    //Enter in Critical section 

  if (variable==0)            //sem_wait
    //Entrace blocked. Wait
```
- Similar to mutex only 1 thread can enter Critical section, But Thread-1 will signal Thread-2 once he's done. Eg: [Binary Semaphore](#t1st2)
```c
  Thread-1()      Critical_Section()      Thread-2()
      ---execute---->                     waiting
                   Thread-1 Done
                   
  signal Thread-2 ------------------------->
  waiting
                      <--------execute--------                  
```

<a name=t></a>
## Types of Semaphores
<a name=b></a>
### Binary
Can take only 2 values (0 or 1).
<a name=t1st2></a>
#### Thread1 signals Thread2 to enter Critical Section, when Thread1 is done
```c++
#include<iostream>
#include<thread>
#include<unistd.h>
#include<semaphore.h>
sem_t sem;

void CriticalSection() {
  std::cout<<"Critical section\n\n";
  sleep(1);
}

void thread1(int a){
  for(;;) {
    std::cout<<"Thread1 inside ";
    CriticalSection();                //2. Thread1 goes into Critical Section, does processing
    sem_post (&sem);                  //3. Thread1 informs Thread2, that Thread1 is out of Critical Section
  }
}
void thread2(int a){
  for (;;) {
    sem_wait(&sem);
    std::cout<<"Thread2 inside ";
    CriticalSection();                  //4. Thread2 enters Critical Section
  }
}

int main(){
  std::thread t1(thread1, 5);            //1. Two Threads created.
  std::thread t2(thread2, 5);
  t1.join();
  t2.join();
}

# .a/out
Thread1 in Critical section
Thread2 in Critical section
Thread1 in Critical section
Thread2 in Critical section
```
