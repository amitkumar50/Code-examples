:toc:
:toclevels: 6


== Borrowing = Reference (&var)

=== 2. Two Mutable references are not allowed in same scope
- *Why?* To avoid data race conditions. Race condition occurs when any of 3 behaviours happen:
    - Two or more pointers access the same data at the same time.
    - At least one of the pointers is being used to write to the data.
    - There’s no mechanism being used to synchronize access to the data.
```rust
  let mut s = String::from("hello");
  let r1 = &mut s;
  let r2 = &mut s;                            //Compilation Error
  println!("{}, {}", r1, r2);
```
=== 3. Mutable References are allowed in seperate scope
```rustc
  let mut s = String::from("hello");
  {
    let r1 = &mut s;
  } // r1 goes out of scope here, so we can make a new reference with no problems.
  let r2 = &mut s;
```

== Borrow Checker
- Rust compiler has a borrow checker that compares scopes to determine whether all borrows are valid.
- _Lifetimes_
  - a is main()'s block
  - b is Block-1
```rs
fn main() {
  let a = 10;
  {                   //Block-1
    let mut b = &a;
  }
  println!("{}",b);   //Compile Error, Borrow=Reference of variable goes out of scope and used.
}
```
=== 1. Generic / Named Lifetimes
- **Compliation Error. Why?** rustc cannot ascertain Return value (&str) is reference of a or reference of b.
```rs
fn largest(x:&str, y:&str) -> &str{
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
fn main() {
    println!("{}", largest(String::from("abcd"), String::from("xyz")));
}
$ cargo run                 //Compilation error
   Compiling 
error[E0106]: missing lifetime specifier
 --> src/test.rs:9:33
  |
9 | fn largest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameterr
```
- **Solution: Generic lifetime parameter `'a`** 
  - Prefix every parameter with `'a`. Apostrophe a (`'a`) denotes reference has generic lifetime. This is also called _Lifetime Annotation Syntax_.
  - Lifetime of references still does not change. 
  - Lifetime annotations only need to be declared in function parameters, it does not goes inside body of function.
  - Examples
```rs
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```
- Fixed code
```rs
fn largest<'a>(x:&'a str, y:&'a str) -> &'a str{           //Need to declare generic lifetime parameters inside <> before parameter list.
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
fn main() {
    println!("{}", largest(&String::from("abcd"), &String::from("xyz")));
}
$ cargo run
$ test.exe
abcd
```

==== 1.1 Function will return smaller of both lifetimes
```rs
fn main() {                           //Block-1
    let x = String::from("abcd");
    let result;
    {                                 //Block-2
        let y = String::from("xyz");
        result = largest(x, y);
    }
    println!("{}", result);           //Printing string which is out of scope
}
```
Compliation Error Why?
- largest() will return smaller lifetime from x and y. y has smaller lifetime(ie Block-2).
- largest() will return y, which goes out of scope and we try printing string which is out of scope

== Lifetime Elision
- The patterns programmed into Rust complier which applies lifetime rules in desired situtation.
- **Input lifetimes:** Lifetimes on function or method parameters.
- **Output Lifetimes:** lifetimes on return values.

=== 1. How compiler determines Lifetime
- Compiler uses 3 rules to figure out what lifetimes references have when there aren’t explicit annotations. If the compiler gets to the end of the three rules and there are still references for which it can’t figure out lifetimes, the compiler will stop with an error.
- _Rule-1:_ Each parameter that is a reference gets its own lifetime parameter. 
```rs
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```
- _Rule-2:_ if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters.
```rs
fn foo<'a>(x: &'a i32) -> &'a i32.
```
- _Rule-3:_ If there are multiple input lifetime parameters, but one of them is `&self` or `&mut self`, the lifetime of self is assigned to all output lifetime parameters.

== Lifetime variables for structs
```rs
struct test<'a> {                       //struct having 1 member having lifetime
    part: &'a str,
}
impl<'a> test<'a> {                     //impl need to be declared with lifetime var,
    fn fun(&self) -> i32 {
        3
    }
}
```

==Static lifetime
- This reference can live for the entire duration of the program. All string literals have the 'static lifetime. 
- The text of this string is stored directly in the program’s binary, which is always available
```rs
let s: &'static str = "test";
```
