:toc:
:toclevels: 6

== Function Template
* Generic function that can operate with generic types.
* When we pass template arguments, function templates are instantiated for these argument types.
* We can overload function templates.

=== How it works
```cpp
//At compile time, compiler creates 2 overloaded versions of maxof function.
//maxof(int a, int b){ }
//maxof(const char*, const char*){  }
   
template <class T>
T maxof(T a, T b) {
  return (a>b)?a:b;
}

int main() {
 cout << maxof(4,5) <<endl;                 //Calls as maxof<int> (4,5)
 //cout << maxof(5,7.8) <<endl;             //error: no matching function for call to ‘maximum(int, double)’
 cout << maxof("hellome","hello") <<endl;   //hellome.  calls as maxof<const char*>("hellome", "hello")
}
```

=== Double, class object are not allowed template parameters
```c
template<double T, typename T1>                     //ERROR:  ‘double’ is not a valid type for a template non-type parameter
void fun () {  cout<<"Hello"; }
// if you replace double with int, it will compile

class A{};
template<A s, typename T1>              //‘class A’ is not a valid type for a template non-type parameter
void fun () {  cout<<"Hello"; }

template<string s, typename T1>         //‘class std::__cxx11::basic_string<char>’ is not a valid type for a template non-type parameter
void fun () {  cout<<"Hello"; }
```

=== Assembly (Function Templates)
```cpp
/*      function_template_assembly.cpp

********POINTS TO REMEMBER:**********
1. Stack grows in reverse direction.
  |----stack grows-----|-------------><------heap grows------
 0x450                0x200
 rbp                  rsp       

2. Arguments to function are stored in registers:  rdi, rsi, rdx, rcx, r8...
*************************************

**************HOW TEMPLATES WORKS INTERNALLY? *********
Function overloading

 - Types are defined using Angular brackets <>
 - User-defined-function        Complier-generated-function
        maximum(4,5)            int maximum<int>(int, int)
        maximum('a','b')        char maximum<char>(char, char)
        maximum(4,4.5)          int maximum<int, double>(int, double)
********************************************************

*/
#include<iostream>
using namespace std;

template <class T>                      //OR template <typename T>
T maximum(T a, T b){
        return (a>b)?a:b;
}

int main(){
        cout<<maximum(4,5);
        cout<<maximum('a','b');
}

/*
 ASSEMBLY:

int maximum<int>(int, int):
        push    rbp                     //4a
        mov     rbp, rsp                //4b
        mov     DWORD PTR [rbp-4], edi  //5 Arguments of function stored on stack. *(rbp-4)=edi=4
        mov     DWORD PTR [rbp-8], esi  //5 Arguments of function stored on stack. *(rbp-4)=esi=5
        mov     eax, DWORD PTR [rbp-4]  //6 eax=*(rbp-4)=4
        cmp     eax, DWORD PTR [rbp-8]  //7 if(eax == *(rbp-8))
        jle     .L4
        mov     eax, DWORD PTR [rbp-4]
        jmp     .L6
.L4:
        mov     eax, DWORD PTR [rbp-8]
.L6:
        pop     rbp
        ret

 main:
        push    rbp             //1a
        mov     rbp, rsp        //1b
        mov     esi, 5          //2a.   2nd Function Argument
        mov     edi, 4          //2b.   1st Function Argument
        call    int maximum<int>(int, int)      //3
        mov     esi, eax
        mov     edi, OFFSET FLAT:_ZSt4cout
        call    std::basic_ostream<char, std::char_traits<char> >::operator<<(int)
        mov     esi, 98
        mov     edi, 97
        call    char maximum<char>(char, char)
        movsx   eax, al
        mov     esi, eax
        mov     edi, OFFSET FLAT:_ZSt4cout
        call    std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char)
        mov     eax, 0
        pop     rbp
        ret

STEPS:
1. Function Epilogue.
   a.Push value of rbp0 somewhere on stack
   ------------                        Head
   rbp0     rsp0                Stack | rbp0=0x450 |

   b.Move rbp to rsp
   --------------main---
            rbp1     rsp1

2. Store function arguments in registers.       Registers
                                                edi=4
                                                esi=5
3. call maximum<int> function.          

4. Function Epilogue.
   a.Push value of rbp1 somewhere on stack
   --------------------                 Head
           rbp1      rsp1         Stack | rbp0=0x450 | rbp1=0x400 |

   b.Move rbp to rsp
   -------main------------maximum<int>(int, int)---
                     rbp2                        rsp2

5. Store parameters of function onto stack                   
   -------main------------maximum<int>(int, int)---
                     rbp2 4 5                    rsp2

6. Store arguments in eax                       Registers
                                                eax=4

7. Compare operands. Subtracts 1st operand from other for comparing them, updates Flag register to show results.
*/
```

== Class Template
Generic class which having(Generic member variables, Generic member functions)

=== Rules
==== 1. Template statement need to be written again when template class function is defined outside template class
* Compiler cannot deduce template parameter type(s) for class template. We need to tell compiler the data types we would be using.
* If arguments are of other type and template-type of other type. Compiler will ignore Argument type
```cpp
template <class T>            //OR <typename T>
class A {
  A a, b;                    //Generic Member variables
public:
  A (T x, T y) : a(x), b(y) {}
  A add ();
};

template <class T>                    //A
T A <T>::add(){ 
  return a+b; 
}

int main() {
  A <int> obj(5,6);                  //B
  cout<<obj.add()<<endl;          //11

  A <float> obj1(5.6,6.7);
  cout<<obj1.add()<<endl;         

  A <int> obj2(5.6,6.7);           //C
  cout<<obj2.multiply()<<endl;    //Output: 30
}
```

==== 2. Template can have 0 templated argument
* Only 1 copy of static variable is kept per class
```c++
template < int n >                                //0 templated arguments
struct st {
  static const int val = 2 * st<n-1>::val;
};

template <> 
struct st < 0 > {                                  //0 templated arguments
  static const int val = 1 ;
};

int main() {
    cout << s<10>::val << endl;                //Output=1024
    return 0;
}
```

==== 3. On compile time, compiler creates seperate class for different parameter types.
```cpp
Test<int>::Test()     //class-1
Test<double>::Test()  //class-2
*/
template <class T>
class Test
{
  T val;
public:
  static int count;
  Test()  {   count++;   }
};
 
template<class T>
int Test<T>::count = 0;
 
int main() {
  Test<int> a;
  Test<int> b;
  Test<double> c;
  cout << Test<int>::count   << endl;       //2
  cout << Test<double>::count << endl;      //1
  return 0;
}
```
