**Maximum Score from Performing Multiplication Operations**
- [Approach-1 DP](#a)
  - [Identifying is this DP Problem?](#i)
  - [Logic](#l)
  - Code
    - [CPP](#cpp)
    - [Rust](#rs)

### Maximum Score from Performing Multiplication Operations
- We are given 2 arrays nums(size=n), multipliers(size=m). n>=m
```c
nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
- nums: Number can be choosen from left or right
- multiplier: Number is always choosen from left.
```
- We need to find maximum sum after multiplying numbers from nums, multipliers. **Constriant**:
  - **`nums[i]:`** Choose one number=x from either the start or the end of the array nums.
  - **`multipliers[i]`:** Always choose next number from left in this array.
  - Add `multipliers[i] * x` to your score.
  - Remove x from the array nums.
```c
nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]
output=102
                -5x-10  50       [-3,-3,-2,7,1]     [-5,3,4,6]
                  |
                -3x-5   50+15=65    [-3,-2,7,1]        [3,4,6]
                  |
                -3x3    65-9=56        [-2,7,1]        [4,6]
                /   \
             DP/     \Greedy
        1x4=4+56=60   1x6=6+56=62
        [-2,7] [6]   [-2,7] [4]
            |          |
      7x6=42+60=102  7x4=28+62=90
ans=102
```

<a name=a></a>
## Approach-1, DP
<a name=i></a>
### [Identifying is this DP Problem?](/DS_Questions/Algorithms/Dynamic_Programming#i)
- _1. Problem statement: min/max/longest/largest/Nth Number?_ Yes
- _2. Greedy solution does not fit in?_ Yes
- _3. 2. Optimal Substructure Property:_ if optimal(feasible) solution can be constructed from optimal solutions of its subproblems. Yes

<a name=l></a>
### [Logic = DP Template](/DS_Questions/Algorithms/Dynamic_Programming#tem)
- _1. Define State:_ Maximum product at index=i after selecting (left or right) from `nums[i]` and left most from `multiplier[i]`.
- _2. Function to return State:_ Function to calculate max product at every index.
```c
int dp(i, left) {
  return (max product at step i);
}

/////////What is left?///////
left = Number of LEFT operations done in nums
right = Number of RIGHT operations done in nums
i = how many operations we have done so far, which means multipliers[i]

How to find right using left,i?
- Number of elements picked from leftside = left
- Total elements picked = i
- Picked from right = i - left
  - Index of right most element in nums = nums.size() - 1 
  - Index of right most picked element in nums = nums[(nums.size() - 1) - (i - left)]
  
Hence we need 2 state variables i,left only.
```
3. _Recurrence relation to transition between states:_
- At each state we need to decide whether we need to take `nums[left]` or `nums[right]`, then multiply with `multipliers[i]`
- Then add to score
- Remove `nums[left] or nums[right]`, we will not remove rather increment left.
```c
if we
1. Choose left
  gain = multipliers[i]*nums[left]
  next operation = dp(i+1, left+1)
  score = multipliers[i]*nums[left] + dp(i+1, left+1)

2. Choose right
//right=(nums.size() - 1) - (i - left)
  gain = multipliers[i]*nums[right]
  next operation = dp(i+1, left)
  score = multipliers[i]*nums[right] + dp(i+1, left)
  
  //max_product_at_index_i
  dp(i, left) = max(choose_left, choose_right)  
```
4. Base case: Try finding base case from problem itself and logical thinking.
  - Question says min m operations (ie multiplier.size()). Hence when i=0 return 0, since no product generated by that time.

### Code
<a name=cpp></a>
#### CPP
```cpp
```
