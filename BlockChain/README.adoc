:toc:
:toclevels: 5   // Set the desired depth of the table of contents

=== Blockchain
* This is append-only, immutable distributed ledger that is updateable only via consensus/agreement among peers. There is no single authority of this ledger.
* This is link:(/Networking/OSI-Layers/Layer-7/P2P_OverlayNetwork/)[Peer to Peer] network running over TCP. Same as HTTP,FTP over TCP

=== Why to learn blockchain
* *Decentralization:* no need for a trusted third party or intermediary to validate transactions; instead a consensus mechanism is used to agree on the validity of transactions.
* *Transparency and trust:* As blockchains are shared and everyone can see what is on the blockchain, this allows the system to be transparent and as a result trust is established.
* *Immutable:* Once the data has been written to the blockchain, it is extremely difficult to change it back.
* *High availability:* As the system is based on thousands of nodes in a peerto-peer network, and the data is replicated and updated on each and every node.
* *Highly Secure:* All transactions on a blockchain are cryptographically secured and provide integrity.
* *Cost saving:* As no third party is required in the blockchain model.

=== Limitations of Blockchain
* Scalability
* Adaptability
* Regulation
* Relatively immature technology
* Privacy

=== Terms
[[address]]
==== Address (Sender or Receiver)
* Bitcoin address of node is calculated using Hash of Public key.
* Public generated using <</Networking/OSI-Layers/Layer-3/Security/README.adoc#secp256k1, secp256k1 ECC Algorithm>>.
* Hash is generated using RIPEMD160 + <</Networking/OSI-Layers/Layer-3/Security/Hash_MessageDigest_MAC_HMAC/README.adoc, SHA256>>.
```c
K(public key) = k(pvt key) * G(constant)
K --> |SHA256| --256bit--> |RIPEMD160| --> 160bit(Address)
160bit(Address) --> |Encode(Base58 Check)| --> Bitcoin Address
```

==== Base58, Base58-Check Encoding
===== Base58
* <<address, Public Address>> generated using hash of public key in blockchain is still 160bits long.
* In order to represent long numbers in a compact way, many computer systems use mixed-alphanumeric representations with a base (or radix) higher than 10.
* _Base64:_ (26 lower case, 26 capitals, 10 numerals & 2 more characters(maybe +, /)
* _Base58:_ (26 lower case, 26 capitals(without the four (0, O, l, I))

===== Base58-Check
* 58 Digit (where last 4 digits = checksum for error check)
* Decoding software will calculate the checksum of the data and compare it to the checksum included in the code.

====== C++ Code (Generate Base64Check address)
* <<keys, Private key in blockchain is random number between (1- 2^256^)>>
```cpp
#include <bitcoin/bitcoin.hpp>
int main() {
   // 1. Take a random Private secret key.
   bc::ec_secret secret = bc::decode_hash("038109007313a5807b2eccc082c8c3fbb988a973cacf1a7df9ce725c31b14776");

   // 2. Get public key.
   bc::ec_point public_key = bc::secret_to_public_key(secret);
   std::cout << "Public key: " << bc::encode_hex(public_key) << std::endl;

 // Create Bitcoin address.
 // Normally you can use:
 // bc::payment_address payaddr;
 // bc::set_public_key(payaddr, public_key);
 // const std::string address = payaddr.encoded();
 // Compute hash of public key for P2PKH address.
 const bc::short_hash hash = bc::bitcoin_short_hash(public_key);
 bc::data_chunk unencoded_address;
 // Reserve 25 bytes
 // [ version:1 ]
 // [ hash:20 ]
 // [ checksum:4 ]
 unencoded_address.reserve(25);
 // Version byte, 0 is normal BTC address (P2PKH).
 unencoded_address.push_back(0);
Bitcoin Addresses | 75
 // Hash data
 bc::extend_data(unencoded_address, hash);
 // Checksum is computed by hashing data, and adding 4 bytes from hash.
 bc::append_checksum(unencoded_address);
 // Finally we must encode the result in Bitcoin's base58 encoding
 assert(unencoded_address.size() == 25);
 const std::string address = bc::encode_base58(unencoded_address);
 std::cout << "Address: " << address << std::endl;
 return 0;
}

```

==== Block
This is a Node(singly linked list). This is a transactions bundled together.
```c
struct block {
  struct block_header* bh;
  struct block* prev_block;   //This is Hash pointer(not normal pointer)
  long timestamp;
  long nonce;
  long transaction_counter
  struct transactions* t;
  struct other_attribute* oa;
}
```

==== Electrum
* This is Bitcoin client which allows to interact with the Bitcoin network(bitcoin network is blockchain). With client we can send and receive transactions, and manage your Bitcoin holdings.
* There are two main types of Bitcoin clients:
** *1. Full Node:* These clients download and validate the entire Bitcoin blockchain
** *2. Lightweight Node:* These clients do not download the entire blockchain. Instead, they rely on full nodes to verify transactions for them. Examples:
*** Mycelium, Electrum, Exodus

==== Ethereum
Framework/platform for creating smart contracts. Etherum runs solidity programming language.

==== Ether
Ether is intended as a utility currency to pay for use of the Ethereum platform

==== Genesis Block
1st block in blockchain. This is hardcoded at time when blockchain started.

[[keys]]
==== Keys (Public, Pvt)
* In blockchain, Public Pvt keys are generated using <</Networking/OSI-Layers/Layer-3/Security/README.adoc#secp256k1, secp256k1 ECC Algorithm>>.
* secp256k1 ECC is not same as RSA or DH.

[[mining]]
==== Mining 
* Let's suppose Alice wants to send 1 BTC(bitcoin) to Bob. 
* Alice creates a transaction and sends it on blockchain network.
```c
Transaction
  src_add = Alice_hash    //Hash is public address of entity on blockchain
  amount = 1 BTC
  dst_add = Bob_Hash
```
* Other nodes reads the transaction, but to add this block on blockchain, some complex computation/puzzles need to be solved.
** Nodes(Miners) race to solve the puzzle, and miner who solves it 1st is rewarded with 0.001 BTC.
** Miner-1, solves the puzzle and sends to network for verification. Other miners verifies it using link:/System-Design/Concepts/Terms/Consensus[consensus] and transaction is added as a node to ledger=blockchain.

==== POW(Proof of Work) 
The work done by <<mining, miner(ie mining)>> to solve the puzzle is called POW.

==== Smart Contracts
* These are the programs that run on blockchain having business logic.
* Represents aggrement b/w 2 parties & allows parties to securly conduct business. Properties:
** _1. Immutable(cannot be changed):_ SC creates logs which are immutable, those cannot be changed.
** _2. Distributed:_ Output of contract is Validated/verified by other nodes on the network.

==== Solidity
* High level Object oriented programming language for writing smart contracts.
* Features;
** _1._ Based on C,C++,python
** _2._ Statically typed: Checking happens at compile time.
** _3. Supports inheritance:_ 1 smart contract can be used by other.

==== Wallet
* In the context of blockchain(eg: bitcoin, tezoz), a wallet is a digital tool that allows you to store, manage, and interact with your Bitcoin holdings. It's used to create and manage Bitcoin addresses, which are used to send and receive Bitcoin transactions. A Bitcoin wallet consists of two main components:
* *1. Public Addresses(Hash number):* These are account numbers in blockchain network. You share these addresses with others when you want to receive Bitcoin. They are derived from your wallet's public key.
* *2. Private Keys:* These are secret keys that helps control/access bitcoins associated with your addresses. Whoever has access to the private key has control over the Bitcoin at that address.

=== Features
==== Distributed consensus
==== Transaction verification
Only valid transactions are included in blockchain. When a node publishes a transactions its verified based on a predetermined set of rules, then its included.
