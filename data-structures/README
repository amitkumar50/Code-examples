Big O(n)
Complexity:
1. worst-case: maximum number of steps taken in any instance of size n
2. best-case: minimum number of steps taken in any instance of size n.
3. average-case: average number of steps over all instances of size n

After all, we don’t really
care whether one sorting algorithm sorts six items faster than another, but seek
which algorithm proves faster when sorting 10,000 or 1,000,000 items.

Big Oh notation
1. ignores the difference between multiplicative constants.
	f(n) = 2n and g(n) = n are identical

For all n ≥ n0. We are not concerned about small values of n (i.e. , anything to the left of n0 )
a. f(n) = O(g(n)). c.g(n) is upper bound of f(n). Always f(n)≤ c·g(n)
b. f(n) = Ω(g(n)). c.g(n) is lower bound of f(n). Always f(n)≥ c·g(n)   [Ω:Omega]
c. f(n) = Θ(g(n)). c1·g(n) ≥ f(n) ≥ c2·g(n) [Θ:Theta]


CLASSIFICATION OF DATA STRUCTURES:
		Contigious					Linked
Based on	Arrays						pointers
	  	composed of single slabs of memory		distinct chunks of memory bound together by pointers
Examples	arrays,matrices,heaps & hash tables		lists, trees, and graph adjacency lists
